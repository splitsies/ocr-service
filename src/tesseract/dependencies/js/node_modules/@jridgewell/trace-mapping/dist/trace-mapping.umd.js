var global,factory;global=this,factory=function(exports,sourcemapCodec,resolveUri){function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var resolveUri__default=_interopDefaultLegacy(resolveUri);function resolve(input,base){return base&&!base.endsWith("/")&&(base+="/"),resolveUri__default.default(input,base)}function stripFilename(path){if(!path)return"";const index=path.lastIndexOf("/");return path.slice(0,index+1)}const COLUMN=0,SOURCES_INDEX=1,SOURCE_LINE=2,SOURCE_COLUMN=3,NAMES_INDEX=4,REV_GENERATED_LINE=1,REV_GENERATED_COLUMN=2;function maybeSort(mappings,owned){const unsortedIndex=nextUnsortedSegmentLine(mappings,0);if(unsortedIndex===mappings.length)return mappings;owned||(mappings=mappings.slice());for(let i=unsortedIndex;i<mappings.length;i=nextUnsortedSegmentLine(mappings,i+1))mappings[i]=sortSegments(mappings[i],owned);return mappings}function nextUnsortedSegmentLine(mappings,start){for(let i=start;i<mappings.length;i++)if(!isSorted(mappings[i]))return i;return mappings.length}function isSorted(line){for(let j=1;j<line.length;j++)if(line[j][COLUMN]<line[j-1][COLUMN])return!1;return!0}function sortSegments(line,owned){return owned||(line=line.slice()),line.sort(sortComparator)}function sortComparator(a,b){return a[COLUMN]-b[COLUMN]}let found=!1;function binarySearch(haystack,needle,low,high){for(;low<=high;){const mid=low+(high-low>>1),cmp=haystack[mid][COLUMN]-needle;if(0===cmp)return found=!0,mid;cmp<0?low=mid+1:high=mid-1}return found=!1,low-1}function upperBound(haystack,needle,index){for(let i=index+1;i<haystack.length&&haystack[i][COLUMN]===needle;index=i++);return index}function lowerBound(haystack,needle,index){for(let i=index-1;i>=0&&haystack[i][COLUMN]===needle;index=i--);return index}function memoizedState(){return{lastKey:-1,lastNeedle:-1,lastIndex:-1}}function memoizedBinarySearch(haystack,needle,state,key){const{lastKey:lastKey,lastNeedle:lastNeedle,lastIndex:lastIndex}=state;let low=0,high=haystack.length-1;if(key===lastKey){if(needle===lastNeedle)return found=-1!==lastIndex&&haystack[lastIndex][COLUMN]===needle,lastIndex;needle>=lastNeedle?low=-1===lastIndex?0:lastIndex:high=lastIndex}return state.lastKey=key,state.lastNeedle=needle,state.lastIndex=binarySearch(haystack,needle,low,high)}function buildBySources(decoded,memos){const sources=memos.map(buildNullArray);for(let i=0;i<decoded.length;i++){const line=decoded[i];for(let j=0;j<line.length;j++){const seg=line[j];if(1===seg.length)continue;const sourceIndex=seg[SOURCES_INDEX],sourceLine=seg[SOURCE_LINE],sourceColumn=seg[SOURCE_COLUMN],originalSource=sources[sourceIndex],originalLine=originalSource[sourceLine]||(originalSource[sourceLine]=[]),memo=memos[sourceIndex],index=upperBound(originalLine,sourceColumn,memoizedBinarySearch(originalLine,sourceColumn,memo,sourceLine));insert(originalLine,memo.lastIndex=index+1,[sourceColumn,i,seg[COLUMN]])}}return sources}function insert(array,index,value){for(let i=array.length;i>index;i--)array[i]=array[i-1];array[index]=value}function buildNullArray(){return{__proto__:null}}const AnyMap=function(map,mapUrl){const parsed="string"==typeof map?JSON.parse(map):map;if(!("sections"in parsed))return new TraceMap(parsed,mapUrl);const mappings=[],sources=[],sourcesContent=[],names=[];recurse(parsed,mapUrl,mappings,sources,sourcesContent,names,0,0,1/0,1/0);const joined={version:3,file:parsed.file,names:names,sources:sources,sourcesContent:sourcesContent,mappings:mappings};return exports.presortedDecodedMap(joined)};function recurse(input,mapUrl,mappings,sources,sourcesContent,names,lineOffset,columnOffset,stopLine,stopColumn){const{sections:sections}=input;for(let i=0;i<sections.length;i++){const{map:map,offset:offset}=sections[i];let sl=stopLine,sc=stopColumn;if(i+1<sections.length){const nextOffset=sections[i+1].offset;sl=Math.min(stopLine,lineOffset+nextOffset.line),sl===stopLine?sc=Math.min(stopColumn,columnOffset+nextOffset.column):sl<stopLine&&(sc=columnOffset+nextOffset.column)}addSection(map,mapUrl,mappings,sources,sourcesContent,names,lineOffset+offset.line,columnOffset+offset.column,sl,sc)}}function addSection(input,mapUrl,mappings,sources,sourcesContent,names,lineOffset,columnOffset,stopLine,stopColumn){if("sections"in input)return recurse(...arguments);const map=new TraceMap(input,mapUrl),sourcesOffset=sources.length,namesOffset=names.length,decoded=exports.decodedMappings(map),{resolvedSources:resolvedSources,sourcesContent:contents}=map;if(append(sources,resolvedSources),append(names,map.names),contents)append(sourcesContent,contents);else for(let i=0;i<resolvedSources.length;i++)sourcesContent.push(null);for(let i=0;i<decoded.length;i++){const lineI=lineOffset+i;if(lineI>stopLine)return;const out=getLine(mappings,lineI),cOffset=0===i?columnOffset:0,line=decoded[i];for(let j=0;j<line.length;j++){const seg=line[j],column=cOffset+seg[COLUMN];if(lineI===stopLine&&column>=stopColumn)return;if(1===seg.length){out.push([column]);continue}const sourcesIndex=sourcesOffset+seg[SOURCES_INDEX],sourceLine=seg[SOURCE_LINE],sourceColumn=seg[SOURCE_COLUMN];out.push(4===seg.length?[column,sourcesIndex,sourceLine,sourceColumn]:[column,sourcesIndex,sourceLine,sourceColumn,namesOffset+seg[NAMES_INDEX]])}}}function append(arr,other){for(let i=0;i<other.length;i++)arr.push(other[i])}function getLine(arr,index){for(let i=arr.length;i<=index;i++)arr[i]=[];return arr[index]}const LINE_GTR_ZERO="`line` must be greater than 0 (lines start at line 1)",COL_GTR_EQ_ZERO="`column` must be greater than or equal to 0 (columns start at column 0)",LEAST_UPPER_BOUND=-1,GREATEST_LOWER_BOUND=1;exports.encodedMappings=void 0,exports.decodedMappings=void 0,exports.traceSegment=void 0,exports.originalPositionFor=void 0,exports.generatedPositionFor=void 0,exports.allGeneratedPositionsFor=void 0,exports.eachMapping=void 0,exports.sourceContentFor=void 0,exports.presortedDecodedMap=void 0,exports.decodedMap=void 0,exports.encodedMap=void 0;class TraceMap{constructor(map,mapUrl){const isString="string"==typeof map;if(!isString&&map._decodedMemo)return map;const parsed=isString?JSON.parse(map):map,{version:version,file:file,names:names,sourceRoot:sourceRoot,sources:sources,sourcesContent:sourcesContent}=parsed;this.version=version,this.file=file,this.names=names,this.sourceRoot=sourceRoot,this.sources=sources,this.sourcesContent=sourcesContent;const from=resolve(sourceRoot||"",stripFilename(mapUrl));this.resolvedSources=sources.map((s=>resolve(s||"",from)));const{mappings:mappings}=parsed;"string"==typeof mappings?(this._encoded=mappings,this._decoded=void 0):(this._encoded=void 0,this._decoded=maybeSort(mappings,isString)),this._decodedMemo=memoizedState(),this._bySources=void 0,this._bySourceMemos=void 0}}function clone(map,mappings){return{version:map.version,file:map.file,names:map.names,sourceRoot:map.sourceRoot,sources:map.sources,sourcesContent:map.sourcesContent,mappings:mappings}}function OMapping(source,line,column,name){return{source:source,line:line,column:column,name:name}}function GMapping(line,column){return{line:line,column:column}}function traceSegmentInternal(segments,memo,line,column,bias){let index=memoizedBinarySearch(segments,column,memo,line);return found?index=(bias===LEAST_UPPER_BOUND?upperBound:lowerBound)(segments,column,index):bias===LEAST_UPPER_BOUND&&index++,-1===index||index===segments.length?-1:index}function sliceGeneratedPositions(segments,memo,line,column,bias){let min=traceSegmentInternal(segments,memo,line,column,GREATEST_LOWER_BOUND);if(found||bias!==LEAST_UPPER_BOUND||min++,-1===min||min===segments.length)return[];const matchedColumn=found?column:segments[min][COLUMN];found||(min=lowerBound(segments,matchedColumn,min));const max=upperBound(segments,matchedColumn,min),result=[];for(;min<=max;min++){const segment=segments[min];result.push(GMapping(segment[REV_GENERATED_LINE]+1,segment[REV_GENERATED_COLUMN]))}return result}(()=>{function generatedPosition(map,source,line,column,bias,all){if(--line<0)throw new Error(LINE_GTR_ZERO);if(column<0)throw new Error(COL_GTR_EQ_ZERO);const{sources:sources,resolvedSources:resolvedSources}=map;let sourceIndex=sources.indexOf(source);if(-1===sourceIndex&&(sourceIndex=resolvedSources.indexOf(source)),-1===sourceIndex)return all?[]:GMapping(null,null);const segments=(map._bySources||(map._bySources=buildBySources(exports.decodedMappings(map),map._bySourceMemos=sources.map(memoizedState))))[sourceIndex][line];if(null==segments)return all?[]:GMapping(null,null);const memo=map._bySourceMemos[sourceIndex];if(all)return sliceGeneratedPositions(segments,memo,line,column,bias);const index=traceSegmentInternal(segments,memo,line,column,bias);if(-1===index)return GMapping(null,null);const segment=segments[index];return GMapping(segment[REV_GENERATED_LINE]+1,segment[REV_GENERATED_COLUMN])}exports.encodedMappings=map=>{var _a;return null!==(_a=map._encoded)&&void 0!==_a?_a:map._encoded=sourcemapCodec.encode(map._decoded)},exports.decodedMappings=map=>map._decoded||(map._decoded=sourcemapCodec.decode(map._encoded)),exports.traceSegment=(map,line,column)=>{const decoded=exports.decodedMappings(map);if(line>=decoded.length)return null;const segments=decoded[line],index=traceSegmentInternal(segments,map._decodedMemo,line,column,GREATEST_LOWER_BOUND);return-1===index?null:segments[index]},exports.originalPositionFor=(map,{line:line,column:column,bias:bias})=>{if(--line<0)throw new Error(LINE_GTR_ZERO);if(column<0)throw new Error(COL_GTR_EQ_ZERO);const decoded=exports.decodedMappings(map);if(line>=decoded.length)return OMapping(null,null,null,null);const segments=decoded[line],index=traceSegmentInternal(segments,map._decodedMemo,line,column,bias||GREATEST_LOWER_BOUND);if(-1===index)return OMapping(null,null,null,null);const segment=segments[index];if(1===segment.length)return OMapping(null,null,null,null);const{names:names,resolvedSources:resolvedSources}=map;return OMapping(resolvedSources[segment[SOURCES_INDEX]],segment[SOURCE_LINE]+1,segment[SOURCE_COLUMN],5===segment.length?names[segment[NAMES_INDEX]]:null)},exports.allGeneratedPositionsFor=(map,{source:source,line:line,column:column,bias:bias})=>generatedPosition(map,source,line,column,bias||LEAST_UPPER_BOUND,!0),exports.generatedPositionFor=(map,{source:source,line:line,column:column,bias:bias})=>generatedPosition(map,source,line,column,bias||GREATEST_LOWER_BOUND,!1),exports.eachMapping=(map,cb)=>{const decoded=exports.decodedMappings(map),{names:names,resolvedSources:resolvedSources}=map;for(let i=0;i<decoded.length;i++){const line=decoded[i];for(let j=0;j<line.length;j++){const seg=line[j],generatedLine=i+1,generatedColumn=seg[0];let source=null,originalLine=null,originalColumn=null,name=null;1!==seg.length&&(source=resolvedSources[seg[1]],originalLine=seg[2]+1,originalColumn=seg[3]),5===seg.length&&(name=names[seg[4]]),cb({generatedLine:generatedLine,generatedColumn:generatedColumn,source:source,originalLine:originalLine,originalColumn:originalColumn,name:name})}}},exports.sourceContentFor=(map,source)=>{const{sources:sources,resolvedSources:resolvedSources,sourcesContent:sourcesContent}=map;if(null==sourcesContent)return null;let index=sources.indexOf(source);return-1===index&&(index=resolvedSources.indexOf(source)),-1===index?null:sourcesContent[index]},exports.presortedDecodedMap=(map,mapUrl)=>{const tracer=new TraceMap(clone(map,[]),mapUrl);return tracer._decoded=map.mappings,tracer},exports.decodedMap=map=>clone(map,exports.decodedMappings(map)),exports.encodedMap=map=>clone(map,exports.encodedMappings(map))})(),exports.AnyMap=AnyMap,exports.GREATEST_LOWER_BOUND=GREATEST_LOWER_BOUND,exports.LEAST_UPPER_BOUND=LEAST_UPPER_BOUND,exports.TraceMap=TraceMap,Object.defineProperty(exports,"__esModule",{value:!0})},"object"==typeof exports&&"undefined"!=typeof module?factory(exports,require("@jridgewell/sourcemap-codec"),require("@jridgewell/resolve-uri")):"function"==typeof define&&define.amd?define(["exports","@jridgewell/sourcemap-codec","@jridgewell/resolve-uri"],factory):factory((global="undefined"!=typeof globalThis?globalThis:global||self).traceMapping={},global.sourcemapCodec,global.resolveURI);