Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=parseAndBuildMetadata;var _t=require("@babel/types"),_parser=require("@babel/parser"),_codeFrame=require("@babel/code-frame");const{isCallExpression:isCallExpression,isExpressionStatement:isExpressionStatement,isFunction:isFunction,isIdentifier:isIdentifier,isJSXIdentifier:isJSXIdentifier,isNewExpression:isNewExpression,isPlaceholder:isPlaceholder,isStatement:isStatement,isStringLiteral:isStringLiteral,removePropertiesDeep:removePropertiesDeep,traverse:traverse}=_t,PATTERN=/^[_$A-Z0-9]+$/;function parseAndBuildMetadata(formatter,code,opts){const{placeholderWhitelist:placeholderWhitelist,placeholderPattern:placeholderPattern,preserveComments:preserveComments,syntacticPlaceholders:syntacticPlaceholders}=opts,ast=parseWithCodeFrame(code,opts.parser,syntacticPlaceholders);removePropertiesDeep(ast,{preserveComments:preserveComments}),formatter.validate(ast);const syntactic={placeholders:[],placeholderNames:new Set},legacy={placeholders:[],placeholderNames:new Set},isLegacyRef={value:void 0};return traverse(ast,placeholderVisitorHandler,{syntactic:syntactic,legacy:legacy,isLegacyRef:isLegacyRef,placeholderWhitelist:placeholderWhitelist,placeholderPattern:placeholderPattern,syntacticPlaceholders:syntacticPlaceholders}),Object.assign({ast:ast},isLegacyRef.value?legacy:syntactic)}function placeholderVisitorHandler(node,ancestors,state){var _state$placeholderWhi;let name;if(isPlaceholder(node)){if(!1===state.syntacticPlaceholders)throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");name=node.name.name,state.isLegacyRef.value=!1}else{if(!1===state.isLegacyRef.value||state.syntacticPlaceholders)return;if(isIdentifier(node)||isJSXIdentifier(node))name=node.name,state.isLegacyRef.value=!0;else{if(!isStringLiteral(node))return;name=node.value,state.isLegacyRef.value=!0}}if(!state.isLegacyRef.value&&(null!=state.placeholderPattern||null!=state.placeholderWhitelist))throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");if(state.isLegacyRef.value&&(!1===state.placeholderPattern||!(state.placeholderPattern||PATTERN).test(name))&&(null==(_state$placeholderWhi=state.placeholderWhitelist)||!_state$placeholderWhi.has(name)))return;ancestors=ancestors.slice();const{node:parent,key:key}=ancestors[ancestors.length-1];let type;isStringLiteral(node)||isPlaceholder(node,{expectedNode:"StringLiteral"})?type="string":isNewExpression(parent)&&"arguments"===key||isCallExpression(parent)&&"arguments"===key||isFunction(parent)&&"params"===key?type="param":isExpressionStatement(parent)&&!isPlaceholder(node)?(type="statement",ancestors=ancestors.slice(0,-1)):type=isStatement(node)&&isPlaceholder(node)?"statement":"other";const{placeholders:placeholders,placeholderNames:placeholderNames}=state.isLegacyRef.value?state.legacy:state.syntactic;placeholders.push({name:name,type:type,resolve:ast=>resolveAncestors(ast,ancestors),isDuplicate:placeholderNames.has(name)}),placeholderNames.add(name)}function resolveAncestors(ast,ancestors){let parent=ast;for(let i=0;i<ancestors.length-1;i++){const{key:key,index:index}=ancestors[i];parent=void 0===index?parent[key]:parent[key][index]}const{key:key,index:index}=ancestors[ancestors.length-1];return{parent:parent,key:key,index:index}}function parseWithCodeFrame(code,parserOpts,syntacticPlaceholders){const plugins=(parserOpts.plugins||[]).slice();!1!==syntacticPlaceholders&&plugins.push("placeholders"),parserOpts=Object.assign({allowReturnOutsideFunction:!0,allowSuperOutsideMethod:!0,sourceType:"module"},parserOpts,{plugins:plugins});try{return(0,_parser.parse)(code,parserOpts)}catch(err){const loc=err.loc;throw loc&&(err.message+="\n"+(0,_codeFrame.codeFrameColumns)(code,{start:loc}),err.code="BABEL_TEMPLATE_PARSE_ERROR"),err}}