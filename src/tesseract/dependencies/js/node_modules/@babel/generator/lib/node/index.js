Object.defineProperty(exports,"__esModule",{value:!0}),exports.needsParens=needsParens,exports.needsWhitespace=needsWhitespace,exports.needsWhitespaceAfter=needsWhitespaceAfter,exports.needsWhitespaceBefore=needsWhitespaceBefore;var whitespace=require("./whitespace"),parens=require("./parentheses"),_t=require("@babel/types");const{FLIPPED_ALIAS_KEYS:FLIPPED_ALIAS_KEYS,isCallExpression:isCallExpression,isExpressionStatement:isExpressionStatement,isMemberExpression:isMemberExpression,isNewExpression:isNewExpression}=_t;function expandAliases(obj){const newObj={};function add(type,func){const fn=newObj[type];newObj[type]=fn?function(node,parent,stack){const result=fn(node,parent,stack);return null==result?func(node,parent,stack):result}:func}for(const type of Object.keys(obj)){const aliases=FLIPPED_ALIAS_KEYS[type];if(aliases)for(const alias of aliases)add(alias,obj[type]);else add(type,obj[type])}return newObj}const expandedParens=expandAliases(parens),expandedWhitespaceNodes=expandAliases(whitespace.nodes);function find(obj,node,parent,printStack){const fn=obj[node.type];return fn?fn(node,parent,printStack):null}function isOrHasCallExpression(node){return!!isCallExpression(node)||isMemberExpression(node)&&isOrHasCallExpression(node.object)}function needsWhitespace(node,parent,type){if(!node)return!1;isExpressionStatement(node)&&(node=node.expression);const flag=find(expandedWhitespaceNodes,node,parent);return"number"==typeof flag&&0!=(flag&type)}function needsWhitespaceBefore(node,parent){return needsWhitespace(node,parent,1)}function needsWhitespaceAfter(node,parent){return needsWhitespace(node,parent,2)}function needsParens(node,parent,printStack){return!!parent&&(!(!isNewExpression(parent)||parent.callee!==node||!isOrHasCallExpression(node))||find(expandedParens,node,parent,printStack))}