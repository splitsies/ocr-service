Object.defineProperty(exports,"__esModule",{value:!0}),exports.ArrowFunctionExpression=ArrowFunctionExpression,exports.AssignmentExpression=AssignmentExpression,exports.Binary=Binary,exports.BinaryExpression=BinaryExpression,exports.ClassExpression=ClassExpression,exports.ConditionalExpression=ConditionalExpression,exports.DoExpression=DoExpression,exports.FunctionExpression=FunctionExpression,exports.FunctionTypeAnnotation=FunctionTypeAnnotation,exports.Identifier=Identifier,exports.LogicalExpression=LogicalExpression,exports.NullableTypeAnnotation=NullableTypeAnnotation,exports.ObjectExpression=ObjectExpression,exports.OptionalIndexedAccessType=OptionalIndexedAccessType,exports.OptionalCallExpression=exports.OptionalMemberExpression=OptionalMemberExpression,exports.SequenceExpression=SequenceExpression,exports.TSTypeAssertion=exports.TSSatisfiesExpression=exports.TSAsExpression=TSAsExpression,exports.TSInferType=TSInferType,exports.TSInstantiationExpression=TSInstantiationExpression,exports.TSIntersectionType=exports.TSUnionType=TSUnionType,exports.UnaryLike=UnaryLike,exports.IntersectionTypeAnnotation=exports.UnionTypeAnnotation=UnionTypeAnnotation,exports.UpdateExpression=UpdateExpression,exports.AwaitExpression=exports.YieldExpression=YieldExpression;var _t=require("@babel/types");const{isArrayTypeAnnotation:isArrayTypeAnnotation,isArrowFunctionExpression:isArrowFunctionExpression,isAssignmentExpression:isAssignmentExpression,isAwaitExpression:isAwaitExpression,isBinary:isBinary,isBinaryExpression:isBinaryExpression,isUpdateExpression:isUpdateExpression,isCallExpression:isCallExpression,isClass:isClass,isClassExpression:isClassExpression,isConditional:isConditional,isConditionalExpression:isConditionalExpression,isExportDeclaration:isExportDeclaration,isExportDefaultDeclaration:isExportDefaultDeclaration,isExpressionStatement:isExpressionStatement,isFor:isFor,isForInStatement:isForInStatement,isForOfStatement:isForOfStatement,isForStatement:isForStatement,isFunctionExpression:isFunctionExpression,isIfStatement:isIfStatement,isIndexedAccessType:isIndexedAccessType,isIntersectionTypeAnnotation:isIntersectionTypeAnnotation,isLogicalExpression:isLogicalExpression,isMemberExpression:isMemberExpression,isNewExpression:isNewExpression,isNullableTypeAnnotation:isNullableTypeAnnotation,isObjectPattern:isObjectPattern,isOptionalCallExpression:isOptionalCallExpression,isOptionalMemberExpression:isOptionalMemberExpression,isReturnStatement:isReturnStatement,isSequenceExpression:isSequenceExpression,isSwitchStatement:isSwitchStatement,isTSArrayType:isTSArrayType,isTSAsExpression:isTSAsExpression,isTSInstantiationExpression:isTSInstantiationExpression,isTSIntersectionType:isTSIntersectionType,isTSNonNullExpression:isTSNonNullExpression,isTSOptionalType:isTSOptionalType,isTSRestType:isTSRestType,isTSTypeAssertion:isTSTypeAssertion,isTSUnionType:isTSUnionType,isTaggedTemplateExpression:isTaggedTemplateExpression,isThrowStatement:isThrowStatement,isTypeAnnotation:isTypeAnnotation,isUnaryLike:isUnaryLike,isUnionTypeAnnotation:isUnionTypeAnnotation,isVariableDeclarator:isVariableDeclarator,isWhileStatement:isWhileStatement,isYieldExpression:isYieldExpression,isTSSatisfiesExpression:isTSSatisfiesExpression}=_t,PRECEDENCE={"||":0,"??":0,"|>":0,"&&":1,"|":2,"^":3,"&":4,"==":5,"===":5,"!=":5,"!==":5,"<":6,">":6,"<=":6,">=":6,in:6,instanceof:6,">>":7,"<<":7,">>>":7,"+":8,"-":8,"*":9,"/":9,"%":9,"**":10};function isTSTypeExpression(node){return isTSAsExpression(node)||isTSSatisfiesExpression(node)||isTSTypeAssertion(node)}const isClassExtendsClause=(node,parent)=>isClass(parent,{superClass:node}),hasPostfixPart=(node,parent)=>(isMemberExpression(parent)||isOptionalMemberExpression(parent))&&parent.object===node||(isCallExpression(parent)||isOptionalCallExpression(parent)||isNewExpression(parent))&&parent.callee===node||isTaggedTemplateExpression(parent)&&parent.tag===node||isTSNonNullExpression(parent);function NullableTypeAnnotation(node,parent){return isArrayTypeAnnotation(parent)}function FunctionTypeAnnotation(node,parent,printStack){if(!(printStack.length<3))return isUnionTypeAnnotation(parent)||isIntersectionTypeAnnotation(parent)||isArrayTypeAnnotation(parent)||isTypeAnnotation(parent)&&isArrowFunctionExpression(printStack[printStack.length-3])}function UpdateExpression(node,parent){return hasPostfixPart(node,parent)||isClassExtendsClause(node,parent)}function ObjectExpression(node,parent,printStack){return isFirstInContext(printStack,3)}function DoExpression(node,parent,printStack){return!node.async&&isFirstInContext(printStack,1)}function Binary(node,parent){if("**"===node.operator&&isBinaryExpression(parent,{operator:"**"}))return parent.left===node;if(isClassExtendsClause(node,parent))return!0;if(hasPostfixPart(node,parent)||isUnaryLike(parent)||isAwaitExpression(parent))return!0;if(isBinary(parent)){const parentOp=parent.operator,parentPos=PRECEDENCE[parentOp],nodeOp=node.operator,nodePos=PRECEDENCE[nodeOp];if(parentPos===nodePos&&parent.right===node&&!isLogicalExpression(parent)||parentPos>nodePos)return!0}}function UnionTypeAnnotation(node,parent){return isArrayTypeAnnotation(parent)||isNullableTypeAnnotation(parent)||isIntersectionTypeAnnotation(parent)||isUnionTypeAnnotation(parent)}function OptionalIndexedAccessType(node,parent){return isIndexedAccessType(parent,{objectType:node})}function TSAsExpression(){return!0}function TSUnionType(node,parent){return isTSArrayType(parent)||isTSOptionalType(parent)||isTSIntersectionType(parent)||isTSUnionType(parent)||isTSRestType(parent)}function TSInferType(node,parent){return isTSArrayType(parent)||isTSOptionalType(parent)}function TSInstantiationExpression(node,parent){return(isCallExpression(parent)||isOptionalCallExpression(parent)||isNewExpression(parent)||isTSInstantiationExpression(parent))&&!!parent.typeParameters}function BinaryExpression(node,parent){return"in"===node.operator&&(isVariableDeclarator(parent)||isFor(parent))}function SequenceExpression(node,parent){return!(isForStatement(parent)||isThrowStatement(parent)||isReturnStatement(parent)||isIfStatement(parent)&&parent.test===node||isWhileStatement(parent)&&parent.test===node||isForInStatement(parent)&&parent.right===node||isSwitchStatement(parent)&&parent.discriminant===node||isExpressionStatement(parent)&&parent.expression===node)}function YieldExpression(node,parent){return isBinary(parent)||isUnaryLike(parent)||hasPostfixPart(node,parent)||isAwaitExpression(parent)&&isYieldExpression(node)||isConditionalExpression(parent)&&node===parent.test||isClassExtendsClause(node,parent)}function ClassExpression(node,parent,printStack){return isFirstInContext(printStack,5)}function UnaryLike(node,parent){return hasPostfixPart(node,parent)||isBinaryExpression(parent,{operator:"**",left:node})||isClassExtendsClause(node,parent)}function FunctionExpression(node,parent,printStack){return isFirstInContext(printStack,5)}function ArrowFunctionExpression(node,parent){return isExportDeclaration(parent)||ConditionalExpression(node,parent)}function ConditionalExpression(node,parent){return!!(isUnaryLike(parent)||isBinary(parent)||isConditionalExpression(parent,{test:node})||isAwaitExpression(parent)||isTSTypeExpression(parent))||UnaryLike(node,parent)}function OptionalMemberExpression(node,parent){return isCallExpression(parent,{callee:node})||isMemberExpression(parent,{object:node})}function AssignmentExpression(node,parent){return!!isObjectPattern(node.left)||ConditionalExpression(node,parent)}function LogicalExpression(node,parent){if(isTSTypeExpression(parent))return!0;switch(node.operator){case"||":return!!isLogicalExpression(parent)&&("??"===parent.operator||"&&"===parent.operator);case"&&":return isLogicalExpression(parent,{operator:"??"});case"??":return isLogicalExpression(parent)&&"??"!==parent.operator}}function Identifier(node,parent,printStack){var _node$extra;if(null!=(_node$extra=node.extra)&&_node$extra.parenthesized&&isAssignmentExpression(parent,{left:node})&&(isFunctionExpression(parent.right)||isClassExpression(parent.right))&&null==parent.right.id)return!0;if("let"===node.name){return isFirstInContext(printStack,isMemberExpression(parent,{object:node,computed:!0})||isOptionalMemberExpression(parent,{object:node,computed:!0,optional:!1})?57:32)}return"async"===node.name&&isForOfStatement(parent)&&node===parent.left}function isFirstInContext(printStack,checkParam){const expressionStatement=1&checkParam,arrowBody=2&checkParam,exportDefault=4&checkParam,forHead=8&checkParam,forInHead=16&checkParam,forOfHead=32&checkParam;let i=printStack.length-1;if(i<=0)return;let node=printStack[i];i--;let parent=printStack[i];for(;i>=0;){if(expressionStatement&&isExpressionStatement(parent,{expression:node})||exportDefault&&isExportDefaultDeclaration(parent,{declaration:node})||arrowBody&&isArrowFunctionExpression(parent,{body:node})||forHead&&isForStatement(parent,{init:node})||forInHead&&isForInStatement(parent,{left:node})||forOfHead&&isForOfStatement(parent,{left:node}))return!0;if(!(i>0&&(hasPostfixPart(node,parent)&&!isNewExpression(parent)||isSequenceExpression(parent)&&parent.expressions[0]===node||isUpdateExpression(parent)&&!parent.prefix||isConditional(parent,{test:node})||isBinary(parent,{left:node})||isAssignmentExpression(parent,{left:node}))))return!1;node=parent,i--,parent=printStack[i]}return!1}