Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=splitExportDeclaration;var _t=require("@babel/types");const{cloneNode:cloneNode,exportNamedDeclaration:exportNamedDeclaration,exportSpecifier:exportSpecifier,identifier:identifier,variableDeclaration:variableDeclaration,variableDeclarator:variableDeclarator}=_t;function splitExportDeclaration(exportDeclaration){if(!exportDeclaration.isExportDeclaration()||exportDeclaration.isExportAllDeclaration())throw new Error("Only default and named export declarations can be split.");if(exportDeclaration.isExportDefaultDeclaration()){const declaration=exportDeclaration.get("declaration"),standaloneDeclaration=declaration.isFunctionDeclaration()||declaration.isClassDeclaration(),scope=declaration.isScope()?declaration.scope.parent:declaration.scope;let id=declaration.node.id,needBindingRegistration=!1;id||(needBindingRegistration=!0,id=scope.generateUidIdentifier("default"),(standaloneDeclaration||declaration.isFunctionExpression()||declaration.isClassExpression())&&(declaration.node.id=cloneNode(id)));const updatedDeclaration=standaloneDeclaration?declaration.node:variableDeclaration("var",[variableDeclarator(cloneNode(id),declaration.node)]),updatedExportDeclaration=exportNamedDeclaration(null,[exportSpecifier(cloneNode(id),identifier("default"))]);return exportDeclaration.insertAfter(updatedExportDeclaration),exportDeclaration.replaceWith(updatedDeclaration),needBindingRegistration&&scope.registerDeclaration(exportDeclaration),exportDeclaration}if(exportDeclaration.get("specifiers").length>0)throw new Error("It doesn't make sense to split exported specifiers.");const declaration=exportDeclaration.get("declaration"),bindingIdentifiers=declaration.getOuterBindingIdentifiers(),specifiers=Object.keys(bindingIdentifiers).map((name=>exportSpecifier(identifier(name),identifier(name)))),aliasDeclar=exportNamedDeclaration(null,specifiers);return exportDeclaration.insertAfter(aliasDeclar),exportDeclaration.replaceWith(declaration.node),exportDeclaration}