Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=_default;var _template=require("@babel/template"),_t=require("@babel/types");const{NOT_LOCAL_BINDING:NOT_LOCAL_BINDING,cloneNode:cloneNode,identifier:identifier,isAssignmentExpression:isAssignmentExpression,isAssignmentPattern:isAssignmentPattern,isFunction:isFunction,isIdentifier:isIdentifier,isLiteral:isLiteral,isNullLiteral:isNullLiteral,isObjectMethod:isObjectMethod,isObjectProperty:isObjectProperty,isRegExpLiteral:isRegExpLiteral,isRestElement:isRestElement,isTemplateLiteral:isTemplateLiteral,isVariableDeclarator:isVariableDeclarator,toBindingIdentifierName:toBindingIdentifierName}=_t;function getFunctionArity(node){const count=node.params.findIndex((param=>isAssignmentPattern(param)||isRestElement(param)));return-1===count?node.params.length:count}const buildPropertyMethodAssignmentWrapper=_template.default.statement("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"),buildGeneratorPropertyMethodAssignmentWrapper=_template.default.statement("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"),visitor={"ReferencedIdentifier|BindingIdentifier"(path,state){if(path.node.name!==state.name)return;path.scope.getBindingIdentifier(state.name)===state.outerDeclar&&(state.selfReference=!0,path.stop())}};function getNameFromLiteralId(id){return isNullLiteral(id)?"null":isRegExpLiteral(id)?`_${id.pattern}_${id.flags}`:isTemplateLiteral(id)?id.quasis.map((quasi=>quasi.value.raw)).join(""):void 0!==id.value?id.value+"":""}function wrap(state,method,id,scope){if(state.selfReference){if(!scope.hasBinding(id.name)||scope.hasGlobal(id.name)){if(!isFunction(method))return;let build=buildPropertyMethodAssignmentWrapper;method.generator&&(build=buildGeneratorPropertyMethodAssignmentWrapper);const template=build({FUNCTION:method,FUNCTION_ID:id,FUNCTION_KEY:scope.generateUidIdentifier(id.name)}).expression,params=template.callee.body.body[0].params;for(let i=0,len=getFunctionArity(method);i<len;i++)params.push(scope.generateUidIdentifier("x"));return template}scope.rename(id.name)}method.id=id,scope.getProgramParent().references[id.name]=!0}function visit(node,name,scope){const state={selfAssignment:!1,selfReference:!1,outerDeclar:scope.getBindingIdentifier(name),name:name},binding=scope.getOwnBinding(name);return binding?"param"===binding.kind&&(state.selfReference=!0):(state.outerDeclar||scope.hasGlobal(name))&&scope.traverse(node,visitor,state),state}function _default({node:node,parent:parent,scope:scope,id:id},localBinding=!1,supportUnicodeId=!1){if(node.id)return;if(!isObjectProperty(parent)&&!isObjectMethod(parent,{kind:"method"})||parent.computed&&!isLiteral(parent.key)){if(isVariableDeclarator(parent)){if(id=parent.id,isIdentifier(id)&&!localBinding){const binding=scope.parent.getBinding(id.name);if(binding&&binding.constant&&scope.getBinding(id.name)===binding)return node.id=cloneNode(id),void(node.id[NOT_LOCAL_BINDING]=!0)}}else if(isAssignmentExpression(parent,{operator:"="}))id=parent.left;else if(!id)return}else id=parent.key;let name;if(id&&isLiteral(id)?name=getNameFromLiteralId(id):id&&isIdentifier(id)&&(name=id.name),void 0===name)return;if(!supportUnicodeId&&isFunction(node)&&/[\uD800-\uDFFF]/.test(name))return;name=toBindingIdentifierName(name);const newId=identifier(name);newId[NOT_LOCAL_BINDING]=!0;return wrap(visit(node,name,scope),node,newId,scope)||node}