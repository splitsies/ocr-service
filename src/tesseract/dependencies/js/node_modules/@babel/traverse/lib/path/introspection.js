Object.defineProperty(exports,"__esModule",{value:!0}),exports._guessExecutionStatusRelativeTo=_guessExecutionStatusRelativeTo,exports._resolve=_resolve,exports.canHaveVariableDeclarationOrExpression=canHaveVariableDeclarationOrExpression,exports.canSwapBetweenExpressionAndStatement=canSwapBetweenExpressionAndStatement,exports.equals=equals,exports.getSource=getSource,exports.has=has,exports.is=void 0,exports.isCompletionRecord=isCompletionRecord,exports.isConstantExpression=isConstantExpression,exports.isInStrictMode=isInStrictMode,exports.isNodeType=isNodeType,exports.isStatementOrBlock=isStatementOrBlock,exports.isStatic=isStatic,exports.isnt=isnt,exports.matchesPattern=matchesPattern,exports.referencesImport=referencesImport,exports.resolve=resolve,exports.willIMaybeExecuteBefore=willIMaybeExecuteBefore;var _t=require("@babel/types");const{STATEMENT_OR_BLOCK_KEYS:STATEMENT_OR_BLOCK_KEYS,VISITOR_KEYS:VISITOR_KEYS,isBlockStatement:isBlockStatement,isExpression:isExpression,isIdentifier:isIdentifier,isLiteral:isLiteral,isStringLiteral:isStringLiteral,isType:isType,matchesPattern:_matchesPattern}=_t;function matchesPattern(pattern,allowPartial){return _matchesPattern(this.node,pattern,allowPartial)}function has(key){const val=this.node&&this.node[key];return val&&Array.isArray(val)?!!val.length:!!val}function isStatic(){return this.scope.isStatic(this.node)}const is=has;function isnt(key){return!this.has(key)}function equals(key,value){return this.node[key]===value}function isNodeType(type){return isType(this.type,type)}function canHaveVariableDeclarationOrExpression(){return("init"===this.key||"left"===this.key)&&this.parentPath.isFor()}function canSwapBetweenExpressionAndStatement(replacement){return!("body"!==this.key||!this.parentPath.isArrowFunctionExpression())&&(this.isExpression()?isBlockStatement(replacement):!!this.isBlockStatement()&&isExpression(replacement))}function isCompletionRecord(allowInsideFunction){let path=this,first=!0;do{const{type:type,container:container}=path;if(!first&&(path.isFunction()||"StaticBlock"===type))return!!allowInsideFunction;if(first=!1,Array.isArray(container)&&path.key!==container.length-1)return!1}while((path=path.parentPath)&&!path.isProgram()&&!path.isDoExpression());return!0}function isStatementOrBlock(){return!this.parentPath.isLabeledStatement()&&!isBlockStatement(this.container)&&STATEMENT_OR_BLOCK_KEYS.includes(this.key)}function referencesImport(moduleSource,importName){if(!this.isReferencedIdentifier()){if(this.isJSXMemberExpression()&&this.node.property.name===importName||(this.isMemberExpression()||this.isOptionalMemberExpression())&&(this.node.computed?isStringLiteral(this.node.property,{value:importName}):this.node.property.name===importName)){const object=this.get("object");return object.isReferencedIdentifier()&&object.referencesImport(moduleSource,"*")}return!1}const binding=this.scope.getBinding(this.node.name);if(!binding||"module"!==binding.kind)return!1;const path=binding.path,parent=path.parentPath;return!!parent.isImportDeclaration()&&(parent.node.source.value===moduleSource&&(!importName||(!(!path.isImportDefaultSpecifier()||"default"!==importName)||(!(!path.isImportNamespaceSpecifier()||"*"!==importName)||!(!path.isImportSpecifier()||!isIdentifier(path.node.imported,{name:importName}))))))}function getSource(){const node=this.node;if(node.end){const code=this.hub.getCode();if(code)return code.slice(node.start,node.end)}return""}function willIMaybeExecuteBefore(target){return"after"!==this._guessExecutionStatusRelativeTo(target)}function getOuterFunction(path){return path.isProgram()?path:(path.parentPath.scope.getFunctionParent()||path.parentPath.scope.getProgramParent()).path}function isExecutionUncertain(type,key){switch(type){case"LogicalExpression":case"AssignmentPattern":return"right"===key;case"ConditionalExpression":case"IfStatement":return"consequent"===key||"alternate"===key;case"WhileStatement":case"DoWhileStatement":case"ForInStatement":case"ForOfStatement":return"body"===key;case"ForStatement":return"body"===key||"update"===key;case"SwitchStatement":return"cases"===key;case"TryStatement":return"handler"===key;case"OptionalMemberExpression":return"property"===key;case"OptionalCallExpression":return"arguments"===key;default:return!1}}function isExecutionUncertainInList(paths,maxIndex){for(let i=0;i<maxIndex;i++){const path=paths[i];if(isExecutionUncertain(path.parent.type,path.parentKey))return!0}return!1}exports.is=is;const SYMBOL_CHECKING=Symbol();function _guessExecutionStatusRelativeTo(target){return _guessExecutionStatusRelativeToCached(this,target,new Map)}function _guessExecutionStatusRelativeToCached(base,target,cache){const funcParent={this:getOuterFunction(base),target:getOuterFunction(target)};if(funcParent.target.node!==funcParent.this.node)return _guessExecutionStatusRelativeToDifferentFunctionsCached(base,funcParent.target,cache);const paths={target:target.getAncestry(),this:base.getAncestry()};if(paths.target.indexOf(base)>=0)return"after";if(paths.this.indexOf(target)>=0)return"before";let commonPath;const commonIndex={target:0,this:0};for(;!commonPath&&commonIndex.this<paths.this.length;){const path=paths.this[commonIndex.this];commonIndex.target=paths.target.indexOf(path),commonIndex.target>=0?commonPath=path:commonIndex.this++}if(!commonPath)throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");if(isExecutionUncertainInList(paths.this,commonIndex.this-1)||isExecutionUncertainInList(paths.target,commonIndex.target-1))return"unknown";const divergence={this:paths.this[commonIndex.this-1],target:paths.target[commonIndex.target-1]};if(divergence.target.listKey&&divergence.this.listKey&&divergence.target.container===divergence.this.container)return divergence.target.key>divergence.this.key?"before":"after";const keys=VISITOR_KEYS[commonPath.type],keyPosition={this:keys.indexOf(divergence.this.parentKey),target:keys.indexOf(divergence.target.parentKey)};return keyPosition.target>keyPosition.this?"before":"after"}function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base,target,cache){if(!target.isFunctionDeclaration())return"before"===_guessExecutionStatusRelativeToCached(base,target,cache)?"before":"unknown";if(target.parentPath.isExportDeclaration())return"unknown";const binding=target.scope.getBinding(target.node.id.name);if(!binding.references)return"before";const referencePaths=binding.referencePaths;let allStatus;for(const path of referencePaths){if(!!path.find((path=>path.node===target.node)))continue;if("callee"!==path.key||!path.parentPath.isCallExpression())return"unknown";const status=_guessExecutionStatusRelativeToCached(base,path,cache);if(allStatus&&allStatus!==status)return"unknown";allStatus=status}return allStatus}function _guessExecutionStatusRelativeToDifferentFunctionsCached(base,target,cache){let cached,nodeMap=cache.get(base.node);if(nodeMap){if(cached=nodeMap.get(target.node))return cached===SYMBOL_CHECKING?"unknown":cached}else cache.set(base.node,nodeMap=new Map);nodeMap.set(target.node,SYMBOL_CHECKING);const result=_guessExecutionStatusRelativeToDifferentFunctionsInternal(base,target,cache);return nodeMap.set(target.node,result),result}function resolve(dangerous,resolved){return this._resolve(dangerous,resolved)||this}function _resolve(dangerous,resolved){if(!(resolved&&resolved.indexOf(this)>=0))if((resolved=resolved||[]).push(this),this.isVariableDeclarator()){if(this.get("id").isIdentifier())return this.get("init").resolve(dangerous,resolved)}else if(this.isReferencedIdentifier()){const binding=this.scope.getBinding(this.node.name);if(!binding)return;if(!binding.constant)return;if("module"===binding.kind)return;if(binding.path!==this){const ret=binding.path.resolve(dangerous,resolved);if(this.find((parent=>parent.node===ret.node)))return;return ret}}else{if(this.isTypeCastExpression())return this.get("expression").resolve(dangerous,resolved);if(dangerous&&this.isMemberExpression()){const targetKey=this.toComputedKey();if(!isLiteral(targetKey))return;const targetName=targetKey.value,target=this.get("object").resolve(dangerous,resolved);if(target.isObjectExpression()){const props=target.get("properties");for(const prop of props){if(!prop.isProperty())continue;const key=prop.get("key");let match=prop.isnt("computed")&&key.isIdentifier({name:targetName});if(match=match||key.isLiteral({value:targetName}),match)return prop.get("value").resolve(dangerous,resolved)}}else if(target.isArrayExpression()&&!isNaN(+targetName)){const elem=target.get("elements")[targetName];if(elem)return elem.resolve(dangerous,resolved)}}}}function isConstantExpression(){if(this.isIdentifier()){const binding=this.scope.getBinding(this.node.name);return!!binding&&binding.constant}if(this.isLiteral())return!this.isRegExpLiteral()&&(!this.isTemplateLiteral()||this.get("expressions").every((expression=>expression.isConstantExpression())));if(this.isUnaryExpression())return"void"===this.node.operator&&this.get("argument").isConstantExpression();if(this.isBinaryExpression()){const{operator:operator}=this.node;return"in"!==operator&&"instanceof"!==operator&&this.get("left").isConstantExpression()&&this.get("right").isConstantExpression()}return!1}function isInStrictMode(){return!!(this.isProgram()?this:this.parentPath).find((path=>{if(path.isProgram({sourceType:"module"}))return!0;if(path.isClass())return!0;if(path.isArrowFunctionExpression()&&!path.get("body").isBlockStatement())return!1;let body;if(path.isFunction())body=path.node.body;else{if(!path.isProgram())return!1;body=path.node}for(const directive of body.directives)if("use strict"===directive.value.value)return!0}))}