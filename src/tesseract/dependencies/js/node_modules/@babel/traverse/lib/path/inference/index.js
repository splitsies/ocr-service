Object.defineProperty(exports,"__esModule",{value:!0}),exports._getTypeAnnotation=_getTypeAnnotation,exports.baseTypeStrictlyMatches=baseTypeStrictlyMatches,exports.couldBeBaseType=couldBeBaseType,exports.getTypeAnnotation=getTypeAnnotation,exports.isBaseType=isBaseType,exports.isGenericType=isGenericType;var inferers=require("./inferers"),_t=require("@babel/types");const{anyTypeAnnotation:anyTypeAnnotation,isAnyTypeAnnotation:isAnyTypeAnnotation,isArrayTypeAnnotation:isArrayTypeAnnotation,isBooleanTypeAnnotation:isBooleanTypeAnnotation,isEmptyTypeAnnotation:isEmptyTypeAnnotation,isFlowBaseAnnotation:isFlowBaseAnnotation,isGenericTypeAnnotation:isGenericTypeAnnotation,isIdentifier:isIdentifier,isMixedTypeAnnotation:isMixedTypeAnnotation,isNumberTypeAnnotation:isNumberTypeAnnotation,isStringTypeAnnotation:isStringTypeAnnotation,isTSArrayType:isTSArrayType,isTSTypeAnnotation:isTSTypeAnnotation,isTSTypeReference:isTSTypeReference,isTupleTypeAnnotation:isTupleTypeAnnotation,isTypeAnnotation:isTypeAnnotation,isUnionTypeAnnotation:isUnionTypeAnnotation,isVoidTypeAnnotation:isVoidTypeAnnotation,stringTypeAnnotation:stringTypeAnnotation,voidTypeAnnotation:voidTypeAnnotation}=_t;function getTypeAnnotation(){let type=this.getData("typeAnnotation");return null!=type||(type=this._getTypeAnnotation()||anyTypeAnnotation(),(isTypeAnnotation(type)||isTSTypeAnnotation(type))&&(type=type.typeAnnotation),this.setData("typeAnnotation",type)),type}const typeAnnotationInferringNodes=new WeakSet;function _getTypeAnnotation(){const node=this.node;if(node){if(node.typeAnnotation)return node.typeAnnotation;if(!typeAnnotationInferringNodes.has(node)){typeAnnotationInferringNodes.add(node);try{var _inferer;let inferer=inferers[node.type];if(inferer)return inferer.call(this,node);if(inferer=inferers[this.parentPath.type],null!=(_inferer=inferer)&&_inferer.validParent)return this.parentPath.getTypeAnnotation()}finally{typeAnnotationInferringNodes.delete(node)}}}else if("init"===this.key&&this.parentPath.isVariableDeclarator()){const declar=this.parentPath.parentPath,declarParent=declar.parentPath;return"left"===declar.key&&declarParent.isForInStatement()?stringTypeAnnotation():"left"===declar.key&&declarParent.isForOfStatement()?anyTypeAnnotation():voidTypeAnnotation()}}function isBaseType(baseName,soft){return _isBaseType(baseName,this.getTypeAnnotation(),soft)}function _isBaseType(baseName,type,soft){if("string"===baseName)return isStringTypeAnnotation(type);if("number"===baseName)return isNumberTypeAnnotation(type);if("boolean"===baseName)return isBooleanTypeAnnotation(type);if("any"===baseName)return isAnyTypeAnnotation(type);if("mixed"===baseName)return isMixedTypeAnnotation(type);if("empty"===baseName)return isEmptyTypeAnnotation(type);if("void"===baseName)return isVoidTypeAnnotation(type);if(soft)return!1;throw new Error(`Unknown base type ${baseName}`)}function couldBeBaseType(name){const type=this.getTypeAnnotation();if(isAnyTypeAnnotation(type))return!0;if(isUnionTypeAnnotation(type)){for(const type2 of type.types)if(isAnyTypeAnnotation(type2)||_isBaseType(name,type2,!0))return!0;return!1}return _isBaseType(name,type,!0)}function baseTypeStrictlyMatches(rightArg){const left=this.getTypeAnnotation(),right=rightArg.getTypeAnnotation();return!(isAnyTypeAnnotation(left)||!isFlowBaseAnnotation(left))&&right.type===left.type}function isGenericType(genericName){const type=this.getTypeAnnotation();return!("Array"!==genericName||!(isTSArrayType(type)||isArrayTypeAnnotation(type)||isTupleTypeAnnotation(type)))||(isGenericTypeAnnotation(type)&&isIdentifier(type.id,{name:genericName})||isTSTypeReference(type)&&isIdentifier(type.typeName,{name:genericName}))}