Object.defineProperty(exports,"__esModule",{value:!0}),exports.evaluate=evaluate,exports.evaluateTruthy=evaluateTruthy;const VALID_CALLEES=["String","Number","Math"],INVALID_METHODS=["random"];function isValidCallee(val){return VALID_CALLEES.includes(val)}function isInvalidMethod(val){return INVALID_METHODS.includes(val)}function evaluateTruthy(){const res=this.evaluate();if(res.confident)return!!res.value}function deopt(path,state){state.confident&&(state.deoptPath=path,state.confident=!1)}const Globals=new Map([["undefined",void 0],["Infinity",1/0],["NaN",NaN]]);function evaluateCached(path,state){const{node:node}=path,{seen:seen}=state;if(seen.has(node)){const existing=seen.get(node);return existing.resolved?existing.value:void deopt(path,state)}{const item={resolved:!1};seen.set(node,item);const val=_evaluate(path,state);return state.confident&&(item.resolved=!0,item.value=val),val}}function _evaluate(path,state){if(state.confident){if(path.isSequenceExpression()){const exprs=path.get("expressions");return evaluateCached(exprs[exprs.length-1],state)}if(path.isStringLiteral()||path.isNumericLiteral()||path.isBooleanLiteral())return path.node.value;if(path.isNullLiteral())return null;if(path.isTemplateLiteral())return evaluateQuasis(path,path.node.quasis,state);if(path.isTaggedTemplateExpression()&&path.get("tag").isMemberExpression()){const object=path.get("tag.object"),{node:{name:name}}=object,property=path.get("tag.property");if(object.isIdentifier()&&"String"===name&&!path.scope.getBinding(name)&&property.isIdentifier()&&"raw"===property.node.name)return evaluateQuasis(path,path.node.quasi.quasis,state,!0)}if(path.isConditionalExpression()){const testResult=evaluateCached(path.get("test"),state);if(!state.confident)return;return evaluateCached(testResult?path.get("consequent"):path.get("alternate"),state)}if(path.isExpressionWrapper())return evaluateCached(path.get("expression"),state);if(path.isMemberExpression()&&!path.parentPath.isCallExpression({callee:path.node})){const property=path.get("property"),object=path.get("object");if(object.isLiteral()){const value=object.node.value,type=typeof value;let key=null;if(path.node.computed){if(key=evaluateCached(property,state),!state.confident)return}else property.isIdentifier()&&(key=property.node.name);if(!("number"!==type&&"string"!==type||null==key||"number"!=typeof key&&"string"!=typeof key))return value[key]}}if(path.isReferencedIdentifier()){const binding=path.scope.getBinding(path.node.name);if(binding){if(binding.constantViolations.length>0||path.node.start<binding.path.node.end)return void deopt(binding.path,state);if(binding.hasValue)return binding.value}const name=path.node.name;if(Globals.has(name))return binding?void deopt(binding.path,state):Globals.get(name);const resolved=path.resolve();return resolved===path?void deopt(path,state):evaluateCached(resolved,state)}if(path.isUnaryExpression({prefix:!0})){if("void"===path.node.operator)return;const argument=path.get("argument");if("typeof"===path.node.operator&&(argument.isFunction()||argument.isClass()))return"function";const arg=evaluateCached(argument,state);if(!state.confident)return;switch(path.node.operator){case"!":return!arg;case"+":return+arg;case"-":return-arg;case"~":return~arg;case"typeof":return typeof arg}}if(path.isArrayExpression()){const arr=[],elems=path.get("elements");for(const elem of elems){const elemValue=elem.evaluate();if(!elemValue.confident)return void deopt(elemValue.deopt,state);arr.push(elemValue.value)}return arr}if(path.isObjectExpression()){const obj={},props=path.get("properties");for(const prop of props){if(prop.isObjectMethod()||prop.isSpreadElement())return void deopt(prop,state);const keyPath=prop.get("key");let key;if(prop.node.computed){if(key=keyPath.evaluate(),!key.confident)return void deopt(key.deopt,state);key=key.value}else key=keyPath.isIdentifier()?keyPath.node.name:keyPath.node.value;let value=prop.get("value").evaluate();if(!value.confident)return void deopt(value.deopt,state);value=value.value,obj[key]=value}return obj}if(path.isLogicalExpression()){const wasConfident=state.confident,left=evaluateCached(path.get("left"),state),leftConfident=state.confident;state.confident=wasConfident;const right=evaluateCached(path.get("right"),state),rightConfident=state.confident;switch(path.node.operator){case"||":if(state.confident=leftConfident&&(!!left||rightConfident),!state.confident)return;return left||right;case"&&":if(state.confident=leftConfident&&(!left||rightConfident),!state.confident)return;return left&&right;case"??":if(state.confident=leftConfident&&(null!=left||rightConfident),!state.confident)return;return null!=left?left:right}}if(path.isBinaryExpression()){const left=evaluateCached(path.get("left"),state);if(!state.confident)return;const right=evaluateCached(path.get("right"),state);if(!state.confident)return;switch(path.node.operator){case"-":return left-right;case"+":return left+right;case"/":return left/right;case"*":return left*right;case"%":return left%right;case"**":return Math.pow(left,right);case"<":return left<right;case">":return left>right;case"<=":return left<=right;case">=":return left>=right;case"==":return left==right;case"!=":return left!=right;case"===":return left===right;case"!==":return left!==right;case"|":return left|right;case"&":return left&right;case"^":return left^right;case"<<":return left<<right;case">>":return left>>right;case">>>":return left>>>right}}if(path.isCallExpression()){const callee=path.get("callee");let context,func;if(callee.isIdentifier()&&!path.scope.getBinding(callee.node.name)&&isValidCallee(callee.node.name)&&(func=global[callee.node.name]),callee.isMemberExpression()){const object=callee.get("object"),property=callee.get("property");if(object.isIdentifier()&&property.isIdentifier()&&isValidCallee(object.node.name)&&!isInvalidMethod(property.node.name)&&(context=global[object.node.name],func=context[property.node.name]),object.isLiteral()&&property.isIdentifier()){const type=typeof object.node.value;"string"!==type&&"number"!==type||(context=object.node.value,func=context[property.node.name])}}if(func){const args=path.get("arguments").map((arg=>evaluateCached(arg,state)));if(!state.confident)return;return func.apply(context,args)}}deopt(path,state)}}function evaluateQuasis(path,quasis,state,raw=!1){let str="",i=0;const exprs=path.isTemplateLiteral()?path.get("expressions"):path.get("quasi.expressions");for(const elem of quasis){if(!state.confident)break;str+=raw?elem.value.raw:elem.value.cooked;const expr=exprs[i++];expr&&(str+=String(evaluateCached(expr,state)))}if(state.confident)return str}function evaluate(){const state={confident:!0,deoptPath:null,seen:new Map};let value=evaluateCached(this,state);return state.confident||(value=void 0),{confident:state.confident,deopt:state.deoptPath,value:value}}