Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=_default;var _t=require("@babel/types"),_util=require("./util");const{BOOLEAN_NUMBER_BINARY_OPERATORS:BOOLEAN_NUMBER_BINARY_OPERATORS,createTypeAnnotationBasedOnTypeof:createTypeAnnotationBasedOnTypeof,numberTypeAnnotation:numberTypeAnnotation,voidTypeAnnotation:voidTypeAnnotation}=_t;function _default(node){if(!this.isReferenced())return;const binding=this.scope.getBinding(node.name);return binding?binding.identifier.typeAnnotation?binding.identifier.typeAnnotation:getTypeAnnotationBindingConstantViolations(binding,this,node.name):"undefined"===node.name?voidTypeAnnotation():"NaN"===node.name||"Infinity"===node.name?numberTypeAnnotation():void node.name}function getTypeAnnotationBindingConstantViolations(binding,path,name){const types=[],functionConstantViolations=[];let constantViolations=getConstantViolationsBefore(binding,path,functionConstantViolations);const testType=getConditionalAnnotation(binding,path,name);if(testType){const testConstantViolations=getConstantViolationsBefore(binding,testType.ifStatement);constantViolations=constantViolations.filter((path=>testConstantViolations.indexOf(path)<0)),types.push(testType.typeAnnotation)}if(constantViolations.length){constantViolations.push(...functionConstantViolations);for(const violation of constantViolations)types.push(violation.getTypeAnnotation())}if(types.length)return(0,_util.createUnionType)(types)}function getConstantViolationsBefore(binding,path,functions){const violations=binding.constantViolations.slice();return violations.unshift(binding.path),violations.filter((violation=>{const status=(violation=violation.resolve())._guessExecutionStatusRelativeTo(path);return functions&&"unknown"===status&&functions.push(violation),"before"===status}))}function inferAnnotationFromBinaryExpression(name,path){const operator=path.node.operator,right=path.get("right").resolve(),left=path.get("left").resolve();let target,typeofPath,typePath;if(left.isIdentifier({name:name})?target=right:right.isIdentifier({name:name})&&(target=left),target)return"==="===operator?target.getTypeAnnotation():BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator)>=0?numberTypeAnnotation():void 0;if("==="!==operator&&"=="!==operator)return;if(left.isUnaryExpression({operator:"typeof"})?(typeofPath=left,typePath=right):right.isUnaryExpression({operator:"typeof"})&&(typeofPath=right,typePath=left),!typeofPath)return;if(!typeofPath.get("argument").isIdentifier({name:name}))return;if(typePath=typePath.resolve(),!typePath.isLiteral())return;const typeValue=typePath.node.value;return"string"==typeof typeValue?createTypeAnnotationBasedOnTypeof(typeValue):void 0}function getParentConditionalPath(binding,path,name){let parentPath;for(;parentPath=path.parentPath;){if(parentPath.isIfStatement()||parentPath.isConditionalExpression()){if("test"===path.key)return;return parentPath}if(parentPath.isFunction()&&parentPath.parentPath.scope.getBinding(name)!==binding)return;path=parentPath}}function getConditionalAnnotation(binding,path,name){const ifStatement=getParentConditionalPath(binding,path,name);if(!ifStatement)return;const paths=[ifStatement.get("test")],types=[];for(let i=0;i<paths.length;i++){const path=paths[i];if(path.isLogicalExpression())"&&"===path.node.operator&&(paths.push(path.get("left")),paths.push(path.get("right")));else if(path.isBinaryExpression()){const type=inferAnnotationFromBinaryExpression(name,path);type&&types.push(type)}}return types.length?{typeAnnotation:(0,_util.createUnionType)(types),ifStatement:ifStatement}:getConditionalAnnotation(binding,ifStatement,name)}