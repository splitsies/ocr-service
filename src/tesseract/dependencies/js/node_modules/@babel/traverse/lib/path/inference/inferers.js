Object.defineProperty(exports,"__esModule",{value:!0}),exports.ArrayExpression=ArrayExpression,exports.AssignmentExpression=AssignmentExpression,exports.BinaryExpression=BinaryExpression,exports.BooleanLiteral=BooleanLiteral,exports.CallExpression=CallExpression,exports.ConditionalExpression=ConditionalExpression,exports.ClassDeclaration=exports.ClassExpression=exports.FunctionDeclaration=exports.ArrowFunctionExpression=exports.FunctionExpression=Func,Object.defineProperty(exports,"Identifier",{enumerable:!0,get:function(){return _infererReference.default}}),exports.LogicalExpression=LogicalExpression,exports.NewExpression=NewExpression,exports.NullLiteral=NullLiteral,exports.NumericLiteral=NumericLiteral,exports.ObjectExpression=ObjectExpression,exports.ParenthesizedExpression=ParenthesizedExpression,exports.RegExpLiteral=RegExpLiteral,exports.RestElement=RestElement,exports.SequenceExpression=SequenceExpression,exports.StringLiteral=StringLiteral,exports.TSAsExpression=TSAsExpression,exports.TSNonNullExpression=TSNonNullExpression,exports.TaggedTemplateExpression=TaggedTemplateExpression,exports.TemplateLiteral=TemplateLiteral,exports.TypeCastExpression=TypeCastExpression,exports.UnaryExpression=UnaryExpression,exports.UpdateExpression=UpdateExpression,exports.VariableDeclarator=VariableDeclarator;var _t=require("@babel/types"),_infererReference=require("./inferer-reference"),_util=require("./util");const{BOOLEAN_BINARY_OPERATORS:BOOLEAN_BINARY_OPERATORS,BOOLEAN_UNARY_OPERATORS:BOOLEAN_UNARY_OPERATORS,NUMBER_BINARY_OPERATORS:NUMBER_BINARY_OPERATORS,NUMBER_UNARY_OPERATORS:NUMBER_UNARY_OPERATORS,STRING_UNARY_OPERATORS:STRING_UNARY_OPERATORS,anyTypeAnnotation:anyTypeAnnotation,arrayTypeAnnotation:arrayTypeAnnotation,booleanTypeAnnotation:booleanTypeAnnotation,buildMatchMemberExpression:buildMatchMemberExpression,genericTypeAnnotation:genericTypeAnnotation,identifier:identifier,nullLiteralTypeAnnotation:nullLiteralTypeAnnotation,numberTypeAnnotation:numberTypeAnnotation,stringTypeAnnotation:stringTypeAnnotation,tupleTypeAnnotation:tupleTypeAnnotation,unionTypeAnnotation:unionTypeAnnotation,voidTypeAnnotation:voidTypeAnnotation,isIdentifier:isIdentifier}=_t;function VariableDeclarator(){if(this.get("id").isIdentifier())return this.get("init").getTypeAnnotation()}function TypeCastExpression(node){return node.typeAnnotation}function TSAsExpression(node){return node.typeAnnotation}function TSNonNullExpression(){return this.get("expression").getTypeAnnotation()}function NewExpression(node){if("Identifier"===node.callee.type)return genericTypeAnnotation(node.callee)}function TemplateLiteral(){return stringTypeAnnotation()}function UnaryExpression(node){const operator=node.operator;return"void"===operator?voidTypeAnnotation():NUMBER_UNARY_OPERATORS.indexOf(operator)>=0?numberTypeAnnotation():STRING_UNARY_OPERATORS.indexOf(operator)>=0?stringTypeAnnotation():BOOLEAN_UNARY_OPERATORS.indexOf(operator)>=0?booleanTypeAnnotation():void 0}function BinaryExpression(node){const operator=node.operator;if(NUMBER_BINARY_OPERATORS.indexOf(operator)>=0)return numberTypeAnnotation();if(BOOLEAN_BINARY_OPERATORS.indexOf(operator)>=0)return booleanTypeAnnotation();if("+"===operator){const right=this.get("right"),left=this.get("left");return left.isBaseType("number")&&right.isBaseType("number")?numberTypeAnnotation():left.isBaseType("string")||right.isBaseType("string")?stringTypeAnnotation():unionTypeAnnotation([stringTypeAnnotation(),numberTypeAnnotation()])}}function LogicalExpression(){const argumentTypes=[this.get("left").getTypeAnnotation(),this.get("right").getTypeAnnotation()];return(0,_util.createUnionType)(argumentTypes)}function ConditionalExpression(){const argumentTypes=[this.get("consequent").getTypeAnnotation(),this.get("alternate").getTypeAnnotation()];return(0,_util.createUnionType)(argumentTypes)}function SequenceExpression(){return this.get("expressions").pop().getTypeAnnotation()}function ParenthesizedExpression(){return this.get("expression").getTypeAnnotation()}function AssignmentExpression(){return this.get("right").getTypeAnnotation()}function UpdateExpression(node){const operator=node.operator;if("++"===operator||"--"===operator)return numberTypeAnnotation()}function StringLiteral(){return stringTypeAnnotation()}function NumericLiteral(){return numberTypeAnnotation()}function BooleanLiteral(){return booleanTypeAnnotation()}function NullLiteral(){return nullLiteralTypeAnnotation()}function RegExpLiteral(){return genericTypeAnnotation(identifier("RegExp"))}function ObjectExpression(){return genericTypeAnnotation(identifier("Object"))}function ArrayExpression(){return genericTypeAnnotation(identifier("Array"))}function RestElement(){return ArrayExpression()}function Func(){return genericTypeAnnotation(identifier("Function"))}TypeCastExpression.validParent=!0,TSAsExpression.validParent=!0,RestElement.validParent=!0;const isArrayFrom=buildMatchMemberExpression("Array.from"),isObjectKeys=buildMatchMemberExpression("Object.keys"),isObjectValues=buildMatchMemberExpression("Object.values"),isObjectEntries=buildMatchMemberExpression("Object.entries");function CallExpression(){const{callee:callee}=this.node;return isObjectKeys(callee)?arrayTypeAnnotation(stringTypeAnnotation()):isArrayFrom(callee)||isObjectValues(callee)||isIdentifier(callee,{name:"Array"})?arrayTypeAnnotation(anyTypeAnnotation()):isObjectEntries(callee)?arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(),anyTypeAnnotation()])):resolveCall(this.get("callee"))}function TaggedTemplateExpression(){return resolveCall(this.get("tag"))}function resolveCall(callee){if((callee=callee.resolve()).isFunction()){const{node:node}=callee;if(node.async)return node.generator?genericTypeAnnotation(identifier("AsyncIterator")):genericTypeAnnotation(identifier("Promise"));if(node.generator)return genericTypeAnnotation(identifier("Iterator"));if(callee.node.returnType)return callee.node.returnType}}