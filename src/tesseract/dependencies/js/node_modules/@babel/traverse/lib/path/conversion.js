Object.defineProperty(exports,"__esModule",{value:!0}),exports.arrowFunctionToExpression=arrowFunctionToExpression,exports.ensureBlock=ensureBlock,exports.toComputedKey=toComputedKey,exports.unwrapFunctionEnvironment=unwrapFunctionEnvironment;var _t=require("@babel/types"),_helperEnvironmentVisitor=require("@babel/helper-environment-visitor"),_helperFunctionName=require("@babel/helper-function-name"),_visitors=require("../visitors");const{arrowFunctionExpression:arrowFunctionExpression,assignmentExpression:assignmentExpression,binaryExpression:binaryExpression,blockStatement:blockStatement,callExpression:callExpression,conditionalExpression:conditionalExpression,expressionStatement:expressionStatement,identifier:identifier,isIdentifier:isIdentifier,jsxIdentifier:jsxIdentifier,logicalExpression:logicalExpression,LOGICAL_OPERATORS:LOGICAL_OPERATORS,memberExpression:memberExpression,metaProperty:metaProperty,numericLiteral:numericLiteral,objectExpression:objectExpression,restElement:restElement,returnStatement:returnStatement,sequenceExpression:sequenceExpression,spreadElement:spreadElement,stringLiteral:stringLiteral,super:_super,thisExpression:thisExpression,toExpression:toExpression,unaryExpression:unaryExpression}=_t;function toComputedKey(){let key;if(this.isMemberExpression())key=this.node.property;else{if(!this.isProperty()&&!this.isMethod())throw new ReferenceError("todo");key=this.node.key}return this.node.computed||isIdentifier(key)&&(key=stringLiteral(key.name)),key}function ensureBlock(){const body=this.get("body"),bodyNode=body.node;if(Array.isArray(body))throw new Error("Can't convert array path to a block statement");if(!bodyNode)throw new Error("Can't convert node without a body");if(body.isBlockStatement())return bodyNode;const statements=[];let key,listKey,stringPath="body";body.isStatement()?(listKey="body",key=0,statements.push(body.node)):(stringPath+=".body.0",this.isFunction()?(key="argument",statements.push(returnStatement(body.node))):(key="expression",statements.push(expressionStatement(body.node)))),this.node.body=blockStatement(statements);const parentPath=this.get(stringPath);return body.setup(parentPath,listKey?parentPath.node[listKey]:parentPath.node,listKey,key),this.node}function unwrapFunctionEnvironment(){if(!this.isArrowFunctionExpression()&&!this.isFunctionExpression()&&!this.isFunctionDeclaration())throw this.buildCodeFrameError("Can only unwrap the environment of a function.");hoistFunctionEnvironment(this)}function setType(path,type){path.node.type=type}function arrowFunctionToExpression({allowInsertArrow:allowInsertArrow=!0,allowInsertArrowWithRest:allowInsertArrowWithRest=allowInsertArrow,noNewArrows:noNewArrows=!(()=>{var _arguments$;return null==(_arguments$=arguments[0])?void 0:_arguments$.specCompliant})()}={}){if(!this.isArrowFunctionExpression())throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");const{thisBinding:thisBinding,fnPath:fn}=hoistFunctionEnvironment(this,noNewArrows,allowInsertArrow,allowInsertArrowWithRest);if(fn.ensureBlock(),setType(fn,"FunctionExpression"),!noNewArrows){const checkBinding=thisBinding?null:fn.scope.generateUidIdentifier("arrowCheckId");return checkBinding&&fn.parentPath.scope.push({id:checkBinding,init:objectExpression([])}),fn.get("body").unshiftContainer("body",expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"),[thisExpression(),identifier(checkBinding?checkBinding.name:thisBinding)]))),fn.replaceWith(callExpression(memberExpression((0,_helperFunctionName.default)(this,!0)||fn.node,identifier("bind")),[checkBinding?identifier(checkBinding.name):thisExpression()])),fn.get("callee.object")}return fn}exports.arrowFunctionToShadowed=function(){this.isArrowFunctionExpression()&&this.arrowFunctionToExpression()};const getSuperCallsVisitor=(0,_visitors.merge)([{CallExpression(child,{allSuperCalls:allSuperCalls}){child.get("callee").isSuper()&&allSuperCalls.push(child)}},_helperEnvironmentVisitor.default]);function hoistFunctionEnvironment(fnPath,noNewArrows=!0,allowInsertArrow=!0,allowInsertArrowWithRest=!0){let arrowParent,thisEnvFn=fnPath.findParent((p=>p.isArrowFunctionExpression()?(null!=arrowParent||(arrowParent=p),!1):p.isFunction()||p.isProgram()||p.isClassProperty({static:!1})||p.isClassPrivateProperty({static:!1})));const inConstructor=thisEnvFn.isClassMethod({kind:"constructor"});if(thisEnvFn.isClassProperty()||thisEnvFn.isClassPrivateProperty())if(arrowParent)thisEnvFn=arrowParent;else{if(!allowInsertArrow)throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");fnPath.replaceWith(callExpression(arrowFunctionExpression([],toExpression(fnPath.node)),[])),thisEnvFn=fnPath.get("callee"),fnPath=thisEnvFn.get("body")}const{thisPaths:thisPaths,argumentsPaths:argumentsPaths,newTargetPaths:newTargetPaths,superProps:superProps,superCalls:superCalls}=getScopeInformation(fnPath);if(inConstructor&&superCalls.length>0){if(!allowInsertArrow)throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");if(!allowInsertArrowWithRest)throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");const allSuperCalls=[];thisEnvFn.traverse(getSuperCallsVisitor,{allSuperCalls:allSuperCalls});const superBinding=getSuperBinding(thisEnvFn);allSuperCalls.forEach((superCall=>{const callee=identifier(superBinding);callee.loc=superCall.node.callee.loc,superCall.get("callee").replaceWith(callee)}))}if(argumentsPaths.length>0){const argumentsBinding=getBinding(thisEnvFn,"arguments",(()=>{const args=()=>identifier("arguments");return thisEnvFn.scope.path.isProgram()?conditionalExpression(binaryExpression("===",unaryExpression("typeof",args()),stringLiteral("undefined")),thisEnvFn.scope.buildUndefinedNode(),args()):args()}));argumentsPaths.forEach((argumentsChild=>{const argsRef=identifier(argumentsBinding);argsRef.loc=argumentsChild.node.loc,argumentsChild.replaceWith(argsRef)}))}if(newTargetPaths.length>0){const newTargetBinding=getBinding(thisEnvFn,"newtarget",(()=>metaProperty(identifier("new"),identifier("target"))));newTargetPaths.forEach((targetChild=>{const targetRef=identifier(newTargetBinding);targetRef.loc=targetChild.node.loc,targetChild.replaceWith(targetRef)}))}if(superProps.length>0){if(!allowInsertArrow)throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");superProps.reduce(((acc,superProp)=>acc.concat(standardizeSuperProperty(superProp))),[]).forEach((superProp=>{const key=superProp.node.computed?"":superProp.get("property").node.name,superParentPath=superProp.parentPath,isAssignment=superParentPath.isAssignmentExpression({left:superProp.node}),isCall=superParentPath.isCallExpression({callee:superProp.node}),isTaggedTemplate=superParentPath.isTaggedTemplateExpression({tag:superProp.node}),superBinding=getSuperPropBinding(thisEnvFn,isAssignment,key),args=[];if(superProp.node.computed&&args.push(superProp.get("property").node),isAssignment){const value=superParentPath.node.right;args.push(value)}const call=callExpression(identifier(superBinding),args);isCall?(superParentPath.unshiftContainer("arguments",thisExpression()),superProp.replaceWith(memberExpression(call,identifier("call"))),thisPaths.push(superParentPath.get("arguments.0"))):isAssignment?superParentPath.replaceWith(call):isTaggedTemplate?(superProp.replaceWith(callExpression(memberExpression(call,identifier("bind"),!1),[thisExpression()])),thisPaths.push(superProp.get("arguments.0"))):superProp.replaceWith(call)}))}let thisBinding;return(thisPaths.length>0||!noNewArrows)&&(thisBinding=getThisBinding(thisEnvFn,inConstructor),(noNewArrows||inConstructor&&hasSuperClass(thisEnvFn))&&(thisPaths.forEach((thisChild=>{const thisRef=thisChild.isJSX()?jsxIdentifier(thisBinding):identifier(thisBinding);thisRef.loc=thisChild.node.loc,thisChild.replaceWith(thisRef)})),noNewArrows||(thisBinding=null))),{thisBinding:thisBinding,fnPath:fnPath}}function isLogicalOp(op){return LOGICAL_OPERATORS.includes(op)}function standardizeSuperProperty(superProp){if(superProp.parentPath.isAssignmentExpression()&&"="!==superProp.parentPath.node.operator){const assignmentPath=superProp.parentPath,op=assignmentPath.node.operator.slice(0,-1),value=assignmentPath.node.right,isLogicalAssignment=isLogicalOp(op);if(superProp.node.computed){const tmp=superProp.scope.generateDeclaredUidIdentifier("tmp"),object=superProp.node.object,property=superProp.node.property;assignmentPath.get("left").replaceWith(memberExpression(object,assignmentExpression("=",tmp,property),!0)),assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment?"=":op,memberExpression(object,identifier(tmp.name),!0),value))}else{const object=superProp.node.object,property=superProp.node.property;assignmentPath.get("left").replaceWith(memberExpression(object,property)),assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment?"=":op,memberExpression(object,identifier(property.name)),value))}return isLogicalAssignment?assignmentPath.replaceWith(logicalExpression(op,assignmentPath.node.left,assignmentPath.node.right)):assignmentPath.node.operator="=",[assignmentPath.get("left"),assignmentPath.get("right").get("left")]}if(superProp.parentPath.isUpdateExpression()){const updateExpr=superProp.parentPath,tmp=superProp.scope.generateDeclaredUidIdentifier("tmp"),computedKey=superProp.node.computed?superProp.scope.generateDeclaredUidIdentifier("prop"):null,parts=[assignmentExpression("=",tmp,memberExpression(superProp.node.object,computedKey?assignmentExpression("=",computedKey,superProp.node.property):superProp.node.property,superProp.node.computed)),assignmentExpression("=",memberExpression(superProp.node.object,computedKey?identifier(computedKey.name):superProp.node.property,superProp.node.computed),binaryExpression(superProp.parentPath.node.operator[0],identifier(tmp.name),numericLiteral(1)))];superProp.parentPath.node.prefix||parts.push(identifier(tmp.name)),updateExpr.replaceWith(sequenceExpression(parts));return[updateExpr.get("expressions.0.right"),updateExpr.get("expressions.1.left")]}return[superProp];function rightExpression(op,left,right){return"="===op?assignmentExpression("=",left,right):binaryExpression(op,left,right)}}function hasSuperClass(thisEnvFn){return thisEnvFn.isClassMethod()&&!!thisEnvFn.parentPath.parentPath.node.superClass}const assignSuperThisVisitor=(0,_visitors.merge)([{CallExpression(child,{supers:supers,thisBinding:thisBinding}){child.get("callee").isSuper()&&(supers.has(child.node)||(supers.add(child.node),child.replaceWithMultiple([child.node,assignmentExpression("=",identifier(thisBinding),identifier("this"))])))}},_helperEnvironmentVisitor.default]);function getThisBinding(thisEnvFn,inConstructor){return getBinding(thisEnvFn,"this",(thisBinding=>{if(!inConstructor||!hasSuperClass(thisEnvFn))return thisExpression();thisEnvFn.traverse(assignSuperThisVisitor,{supers:new WeakSet,thisBinding:thisBinding})}))}function getSuperBinding(thisEnvFn){return getBinding(thisEnvFn,"supercall",(()=>{const argsBinding=thisEnvFn.scope.generateUidIdentifier("args");return arrowFunctionExpression([restElement(argsBinding)],callExpression(_super(),[spreadElement(identifier(argsBinding.name))]))}))}function getSuperPropBinding(thisEnvFn,isAssignment,propName){return getBinding(thisEnvFn,`superprop_${isAssignment?"set":"get"}:${propName||""}`,(()=>{const argsList=[];let fnBody;if(propName)fnBody=memberExpression(_super(),identifier(propName));else{const method=thisEnvFn.scope.generateUidIdentifier("prop");argsList.unshift(method),fnBody=memberExpression(_super(),identifier(method.name),!0)}if(isAssignment){const valueIdent=thisEnvFn.scope.generateUidIdentifier("value");argsList.push(valueIdent),fnBody=assignmentExpression("=",fnBody,identifier(valueIdent.name))}return arrowFunctionExpression(argsList,fnBody)}))}function getBinding(thisEnvFn,key,init){const cacheKey="binding:"+key;let data=thisEnvFn.getData(cacheKey);if(!data){const id=thisEnvFn.scope.generateUidIdentifier(key);data=id.name,thisEnvFn.setData(cacheKey,data),thisEnvFn.scope.push({id:id,init:init(data)})}return data}const getScopeInformationVisitor=(0,_visitors.merge)([{ThisExpression(child,{thisPaths:thisPaths}){thisPaths.push(child)},JSXIdentifier(child,{thisPaths:thisPaths}){"this"===child.node.name&&(child.parentPath.isJSXMemberExpression({object:child.node})||child.parentPath.isJSXOpeningElement({name:child.node}))&&thisPaths.push(child)},CallExpression(child,{superCalls:superCalls}){child.get("callee").isSuper()&&superCalls.push(child)},MemberExpression(child,{superProps:superProps}){child.get("object").isSuper()&&superProps.push(child)},Identifier(child,{argumentsPaths:argumentsPaths}){if(!child.isReferencedIdentifier({name:"arguments"}))return;let curr=child.scope;do{if(curr.hasOwnBinding("arguments"))return void curr.rename("arguments");if(curr.path.isFunction()&&!curr.path.isArrowFunctionExpression())break}while(curr=curr.parent);argumentsPaths.push(child)},MetaProperty(child,{newTargetPaths:newTargetPaths}){child.get("meta").isIdentifier({name:"new"})&&child.get("property").isIdentifier({name:"target"})&&newTargetPaths.push(child)}},_helperEnvironmentVisitor.default]);function getScopeInformation(fnPath){const thisPaths=[],argumentsPaths=[],newTargetPaths=[],superProps=[],superCalls=[];return fnPath.traverse(getScopeInformationVisitor,{thisPaths:thisPaths,argumentsPaths:argumentsPaths,newTargetPaths:newTargetPaths,superProps:superProps,superCalls:superCalls}),{thisPaths:thisPaths,argumentsPaths:argumentsPaths,newTargetPaths:newTargetPaths,superProps:superProps,superCalls:superCalls}}