Object.defineProperty(exports,"__esModule",{value:!0}),exports.explode=explode,exports.merge=merge,exports.verify=verify;var virtualTypes=require("./path/lib/virtual-types"),_t=require("@babel/types");const{DEPRECATED_KEYS:DEPRECATED_KEYS,DEPRECATED_ALIASES:DEPRECATED_ALIASES,FLIPPED_ALIAS_KEYS:FLIPPED_ALIAS_KEYS,TYPES:TYPES,__internal__deprecationWarning:deprecationWarning}=_t;function isVirtualType(type){return type in virtualTypes}function explode(visitor){if(visitor._exploded)return visitor;visitor._exploded=!0;for(const nodeType of Object.keys(visitor)){if(shouldIgnoreKey(nodeType))continue;const parts=nodeType.split("|");if(1===parts.length)continue;const fns=visitor[nodeType];delete visitor[nodeType];for(const part of parts)visitor[part]=fns}verify(visitor),delete visitor.__esModule,ensureEntranceObjects(visitor),ensureCallbackArrays(visitor);for(const nodeType of Object.keys(visitor)){if(shouldIgnoreKey(nodeType))continue;if(!isVirtualType(nodeType))continue;const fns=visitor[nodeType];for(const type of Object.keys(fns))fns[type]=wrapCheck(nodeType,fns[type]);delete visitor[nodeType];const types=virtualTypes[nodeType];if(null!==types)for(const type of types)visitor[type]?mergePair(visitor[type],fns):visitor[type]=fns;else mergePair(visitor,fns)}for(const nodeType of Object.keys(visitor)){if(shouldIgnoreKey(nodeType))continue;let aliases=FLIPPED_ALIAS_KEYS[nodeType];if(nodeType in DEPRECATED_KEYS){const deprecatedKey=DEPRECATED_KEYS[nodeType];deprecationWarning(nodeType,deprecatedKey,"Visitor "),aliases=[deprecatedKey]}else if(nodeType in DEPRECATED_ALIASES){const deprecatedAlias=DEPRECATED_ALIASES[nodeType];deprecationWarning(nodeType,deprecatedAlias,"Visitor "),aliases=FLIPPED_ALIAS_KEYS[deprecatedAlias]}if(!aliases)continue;const fns=visitor[nodeType];delete visitor[nodeType];for(const alias of aliases){const existing=visitor[alias];existing?mergePair(existing,fns):visitor[alias]=Object.assign({},fns)}}for(const nodeType of Object.keys(visitor))shouldIgnoreKey(nodeType)||ensureCallbackArrays(visitor[nodeType]);return visitor}function verify(visitor){if(!visitor._verified){if("function"==typeof visitor)throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");for(const nodeType of Object.keys(visitor)){if("enter"!==nodeType&&"exit"!==nodeType||validateVisitorMethods(nodeType,visitor[nodeType]),shouldIgnoreKey(nodeType))continue;if(TYPES.indexOf(nodeType)<0)throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);const visitors=visitor[nodeType];if("object"==typeof visitors)for(const visitorKey of Object.keys(visitors)){if("enter"!==visitorKey&&"exit"!==visitorKey)throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);validateVisitorMethods(`${nodeType}.${visitorKey}`,visitors[visitorKey])}}visitor._verified=!0}}function validateVisitorMethods(path,val){const fns=[].concat(val);for(const fn of fns)if("function"!=typeof fn)throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`)}function merge(visitors,states=[],wrapper){const rootVisitor={};for(let i=0;i<visitors.length;i++){const visitor=visitors[i],state=states[i];explode(visitor);for(const type of Object.keys(visitor)){let visitorType=visitor[type];(state||wrapper)&&(visitorType=wrapWithStateOrWrapper(visitorType,state,wrapper));mergePair(rootVisitor[type]||(rootVisitor[type]={}),visitorType)}}return rootVisitor}function wrapWithStateOrWrapper(oldVisitor,state,wrapper){const newVisitor={};for(const key of Object.keys(oldVisitor)){let fns=oldVisitor[key];Array.isArray(fns)&&(fns=fns.map((function(fn){let newFn=fn;return state&&(newFn=function(path){return fn.call(state,path,state)}),wrapper&&(newFn=wrapper(state.key,key,newFn)),newFn!==fn&&(newFn.toString=()=>fn.toString()),newFn})),newVisitor[key]=fns)}return newVisitor}function ensureEntranceObjects(obj){for(const key of Object.keys(obj)){if(shouldIgnoreKey(key))continue;const fns=obj[key];"function"==typeof fns&&(obj[key]={enter:fns})}}function ensureCallbackArrays(obj){obj.enter&&!Array.isArray(obj.enter)&&(obj.enter=[obj.enter]),obj.exit&&!Array.isArray(obj.exit)&&(obj.exit=[obj.exit])}function wrapCheck(nodeType,fn){const newFn=function(path){if(path[`is${nodeType}`]())return fn.apply(this,arguments)};return newFn.toString=()=>fn.toString(),newFn}function shouldIgnoreKey(key){return"_"===key[0]||("enter"===key||"exit"===key||"shouldSkip"===key||("denylist"===key||"noScope"===key||"skipKeys"===key||"blacklist"===key))}function mergePair(dest,src){for(const key of Object.keys(src))dest[key]=[].concat(dest[key]||[],src[key])}