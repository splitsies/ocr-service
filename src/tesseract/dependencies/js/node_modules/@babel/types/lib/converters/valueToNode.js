Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _isValidIdentifier=require("../validators/isValidIdentifier"),_generated=require("../builders/generated"),_default=valueToNode;exports.default=_default;const objectToString=Function.call.bind(Object.prototype.toString);function isRegExp(value){return"[object RegExp]"===objectToString(value)}function isPlainObject(value){if("object"!=typeof value||null===value||"[object Object]"!==Object.prototype.toString.call(value))return!1;const proto=Object.getPrototypeOf(value);return null===proto||null===Object.getPrototypeOf(proto)}function valueToNode(value){if(void 0===value)return(0,_generated.identifier)("undefined");if(!0===value||!1===value)return(0,_generated.booleanLiteral)(value);if(null===value)return(0,_generated.nullLiteral)();if("string"==typeof value)return(0,_generated.stringLiteral)(value);if("number"==typeof value){let result;if(Number.isFinite(value))result=(0,_generated.numericLiteral)(Math.abs(value));else{let numerator;numerator=Number.isNaN(value)?(0,_generated.numericLiteral)(0):(0,_generated.numericLiteral)(1),result=(0,_generated.binaryExpression)("/",numerator,(0,_generated.numericLiteral)(0))}return(value<0||Object.is(value,-0))&&(result=(0,_generated.unaryExpression)("-",result)),result}if(isRegExp(value)){const pattern=value.source,flags=value.toString().match(/\/([a-z]+|)$/)[1];return(0,_generated.regExpLiteral)(pattern,flags)}if(Array.isArray(value))return(0,_generated.arrayExpression)(value.map(valueToNode));if(isPlainObject(value)){const props=[];for(const key of Object.keys(value)){let nodeKey;nodeKey=(0,_isValidIdentifier.default)(key)?(0,_generated.identifier)(key):(0,_generated.stringLiteral)(key),props.push((0,_generated.objectProperty)(nodeKey,valueToNode(value[key])))}return(0,_generated.objectExpression)(props)}throw new Error("don't know how to turn this value into a node")}