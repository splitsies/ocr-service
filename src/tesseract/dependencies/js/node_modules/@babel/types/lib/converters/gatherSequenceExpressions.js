Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=gatherSequenceExpressions;var _getBindingIdentifiers=require("../retrievers/getBindingIdentifiers"),_generated=require("../validators/generated"),_generated2=require("../builders/generated"),_cloneNode=require("../clone/cloneNode");function gatherSequenceExpressions(nodes,scope,declars){const exprs=[];let ensureLastUndefined=!0;for(const node of nodes)if((0,_generated.isEmptyStatement)(node)||(ensureLastUndefined=!1),(0,_generated.isExpression)(node))exprs.push(node);else if((0,_generated.isExpressionStatement)(node))exprs.push(node.expression);else if((0,_generated.isVariableDeclaration)(node)){if("var"!==node.kind)return;for(const declar of node.declarations){const bindings=(0,_getBindingIdentifiers.default)(declar);for(const key of Object.keys(bindings))declars.push({kind:node.kind,id:(0,_cloneNode.default)(bindings[key])});declar.init&&exprs.push((0,_generated2.assignmentExpression)("=",declar.id,declar.init))}ensureLastUndefined=!0}else if((0,_generated.isIfStatement)(node)){const consequent=node.consequent?gatherSequenceExpressions([node.consequent],scope,declars):scope.buildUndefinedNode(),alternate=node.alternate?gatherSequenceExpressions([node.alternate],scope,declars):scope.buildUndefinedNode();if(!consequent||!alternate)return;exprs.push((0,_generated2.conditionalExpression)(node.test,consequent,alternate))}else if((0,_generated.isBlockStatement)(node)){const body=gatherSequenceExpressions(node.body,scope,declars);if(!body)return;exprs.push(body)}else{if(!(0,_generated.isEmptyStatement)(node))return;0===nodes.indexOf(node)&&(ensureLastUndefined=!0)}return ensureLastUndefined&&exprs.push(scope.buildUndefinedNode()),1===exprs.length?exprs[0]:(0,_generated2.sequenceExpression)(exprs)}