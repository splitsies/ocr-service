Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=removeTypeDuplicates;var _generated=require("../../validators/generated");function getQualifiedName(node){return(0,_generated.isIdentifier)(node)?node.name:`${node.right.name}.${getQualifiedName(node.left)}`}function removeTypeDuplicates(nodesIn){const nodes=Array.from(nodesIn),generics=new Map,bases=new Map,typeGroups=new Set,types=[];for(let i=0;i<nodes.length;i++){const node=nodes[i];if(node&&!(types.indexOf(node)>=0)){if((0,_generated.isTSAnyKeyword)(node))return[node];if((0,_generated.isTSBaseType)(node))bases.set(node.type,node);else if((0,_generated.isTSUnionType)(node))typeGroups.has(node.types)||(nodes.push(...node.types),typeGroups.add(node.types));else if((0,_generated.isTSTypeReference)(node)&&node.typeParameters){const name=getQualifiedName(node.typeName);if(generics.has(name)){let existing=generics.get(name);existing.typeParameters?node.typeParameters&&(existing.typeParameters.params.push(...node.typeParameters.params),existing.typeParameters.params=removeTypeDuplicates(existing.typeParameters.params)):existing=node.typeParameters}else generics.set(name,node)}else types.push(node)}}for(const[,baseType]of bases)types.push(baseType);for(const[,genericName]of generics)types.push(genericName);return types}