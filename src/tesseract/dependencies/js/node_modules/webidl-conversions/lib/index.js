var conversions={};function sign(x){return x<0?-1:1}function evenRound(x){return x%1==.5&&0==(1&x)?Math.floor(x):Math.round(x)}function createNumberConversion(bitLength,typeOpts){typeOpts.unsigned||--bitLength;const lowerBound=typeOpts.unsigned?0:-Math.pow(2,bitLength),upperBound=Math.pow(2,bitLength)-1,moduloVal=typeOpts.moduloBitLength?Math.pow(2,typeOpts.moduloBitLength):Math.pow(2,bitLength),moduloBound=typeOpts.moduloBitLength?Math.pow(2,typeOpts.moduloBitLength-1):Math.pow(2,bitLength-1);return function(V,opts){opts||(opts={});let x=+V;if(opts.enforceRange){if(!Number.isFinite(x))throw new TypeError("Argument is not a finite number");if(x=sign(x)*Math.floor(Math.abs(x)),x<lowerBound||x>upperBound)throw new TypeError("Argument is not in byte range");return x}if(!isNaN(x)&&opts.clamp)return x=evenRound(x),x<lowerBound&&(x=lowerBound),x>upperBound&&(x=upperBound),x;if(!Number.isFinite(x)||0===x)return 0;if(x=sign(x)*Math.floor(Math.abs(x)),x%=moduloVal,!typeOpts.unsigned&&x>=moduloBound)return x-moduloVal;if(typeOpts.unsigned)if(x<0)x+=moduloVal;else if(-0===x)return 0;return x}}module.exports=conversions,conversions.void=function(){},conversions.boolean=function(val){return!!val},conversions.byte=createNumberConversion(8,{unsigned:!1}),conversions.octet=createNumberConversion(8,{unsigned:!0}),conversions.short=createNumberConversion(16,{unsigned:!1}),conversions["unsigned short"]=createNumberConversion(16,{unsigned:!0}),conversions.long=createNumberConversion(32,{unsigned:!1}),conversions["unsigned long"]=createNumberConversion(32,{unsigned:!0}),conversions["long long"]=createNumberConversion(32,{unsigned:!1,moduloBitLength:64}),conversions["unsigned long long"]=createNumberConversion(32,{unsigned:!0,moduloBitLength:64}),conversions.double=function(V){const x=+V;if(!Number.isFinite(x))throw new TypeError("Argument is not a finite floating-point value");return x},conversions["unrestricted double"]=function(V){const x=+V;if(isNaN(x))throw new TypeError("Argument is NaN");return x},conversions.float=conversions.double,conversions["unrestricted float"]=conversions["unrestricted double"],conversions.DOMString=function(V,opts){return opts||(opts={}),opts.treatNullAsEmptyString&&null===V?"":String(V)},conversions.ByteString=function(V,opts){const x=String(V);let c;for(let i=0;void 0!==(c=x.codePointAt(i));++i)if(c>255)throw new TypeError("Argument is not a valid bytestring");return x},conversions.USVString=function(V){const S=String(V),n=S.length,U=[];for(let i=0;i<n;++i){const c=S.charCodeAt(i);if(c<55296||c>57343)U.push(String.fromCodePoint(c));else if(56320<=c&&c<=57343)U.push(String.fromCodePoint(65533));else if(i===n-1)U.push(String.fromCodePoint(65533));else{const d=S.charCodeAt(i+1);if(56320<=d&&d<=57343){const a=1023&c,b=1023&d;U.push(String.fromCodePoint(65536+1024*a+b)),++i}else U.push(String.fromCodePoint(65533))}}return U.join("")},conversions.Date=function(V,opts){if(!(V instanceof Date))throw new TypeError("Argument is not a Date object");if(!isNaN(V))return V},conversions.RegExp=function(V,opts){return V instanceof RegExp||(V=new RegExp(V)),V};